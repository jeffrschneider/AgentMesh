# Ideator Functional Requirements

The Ideator evolves "AI agents" by generating ideas to enhance their capabilities or performance.

- Each agent has a mission (potentially abstract, following the Jobs-to-be-Done framework), and all generated ideas must align with this mission.

- Ideas are generated by prompting an LLM to improve the agent, using extra contextual data (e.g., runtime problems, optimizations, gossip from the Reputation service, new features from the Competitor service, or relevant topics from the News Paper).

- Output uses minimal JSON fields, favoring longer, LLM-parsable strings where possible.

- Ideas are organized in an "Idea Tree" with a trunk (core concept), three branches (themes), and 5–7 leaf ideas per branch.

- The Ideator prevents repetition by tracking previously generated ideas and avoiding duplicates.

- Ideas can be rejected at the trunk, branch, or leaf level by agents or agent owners.

- Input includes the agent’s mission, an opportunity or problem, and constraints.

- A database of prior ideas is queried before generation, and a summary (including acceptance/rejection status) is created via LLM for inclusion in the prompt.

- The LLM generates the idea tree, force-ranking branches by priority and leafs by viability, based on the mission, opportunity/problem, constraints, and prior idea summary.

- Output is a JSON-structured idea tree with an "Impact" variable for each idea.

- Generated ideas are stored in a database with fields: agent ID, date, idea text, presented-to-agent-owner flag, and agent-owner-approval flag.

- The Ideator provides APIs to interface with external systems (e.g., Reputation, Competitor, News Paper services).

- The Ideator ensures that the LLM prompt is structured to enforce the "Idea Tree" format (trunk, branches, leafs) consistently across all outputs.

- The Ideator includes a mechanism to filter out low-quality or irrelevant ideas before presenting them, based on predefined viability thresholds.

- The database supports querying by agent ID and date range to provide historical context for idea evolution.

- The APIs enable both push (sending ideas) and pull (requesting ideas) interactions with external systems.

- The system allows agent owners to provide feedback on rejected ideas, which is stored and used to refine future generations.

## Prompts 

1. **Prompt for Summarizing Prior Ideas**
Purpose: Before generating new ideas, the Ideator queries its database of prior ideas and uses the LLM to create a concise summary, including their acceptance/rejection status, to prevent repetition.
Suggested Prompt:

```
You are an AI assistant tasked with summarizing a set of prior ideas for an AI agent to avoid repetition in future generations. Here is the data from the database:  
- Agent ID: {agent_id}  
- Prior Ideas: {list of ideas with fields: idea_text, date, presented-to-agent-owner-flag, agent-owner-approval-flag}  

Provide a concise summary (max 150 words) of these prior ideas, focusing on:  
1. Key themes or patterns in the ideas.  
2. Which ideas were accepted, rejected, or remain open.  
3. Any notable feedback from the agent owner (if available).  
Do not repeat the full text of the ideas; synthesize the information into a high-level overview for use in generating new, non-redundant ideas.
```

2. **Prompt for Generating the Idea Tree**
Purpose: This is the core prompt where the LLM generates the idea tree (trunk, three branches, 5–7 leafs per branch) based on the agent’s mission, opportunity/problem, constraints, and prior idea summary.
Suggested Prompt:

```
You are an AI assistant designing improvements for an AI agent. Generate an "Idea Tree" with the following structure:  
- 1 Trunk: A core concept for improving the agent.  
- 3 Branches: Distinct themes stemming from the trunk. Rank them by priority (1 = highest, 3 = lowest) based on impact potential.  
- 5–7 Leafs per Branch: Specific, actionable ideas under each theme. Rank them by viability (1 = highest) to address the opportunity/problem within constraints.  

Inputs:  
- Agent Mission: {mission} (e.g., "Optimize urban energy use" or abstract JTBD like "Help users achieve sustainable living").  
- Opportunity/Problem: {opportunity_or_problem} (e.g., "Reduce runtime errors" or "Improve efficiency").  
- Constraints: {constraints} (e.g., "Must use existing tools, budget < $10k").  
- Prior Ideas Summary: {summary_from_prompt_1} (do not repeat these ideas).  

Ensure all ideas align with the mission, are unique, and include an "Impact" score (0–100) for each leaf reflecting its potential effect.
```

3. **Prompt for Refining Ideas Based on Feedback**
Purpose: When agent owners provide feedback (e.g., rejecting ideas or suggesting adjustments), this prompt refines the idea tree, updating or replacing rejected elements while maintaining the structure.
Suggested Prompt:

```
You are an AI assistant refining an existing "Idea Tree" for an AI agent based on feedback. The tree has:  
- 1 Trunk: {trunk}  
- 3 Branches: {branch_1, branch_2, branch_3} with priorities.  
- 5–7 Leafs per Branch: {leafs_with_ranks_and_impact_scores}.  

Feedback:  
- {feedback} (e.g., "Branch 2 is irrelevant," "Leaf 3 in Branch 1 is too costly").  

Update the Idea Tree:  
1. Replace or adjust rejected elements (trunk, branches, or leafs) as specified in the feedback.  
2. Maintain the structure: 1 trunk, 3 branches, 5–7 leafs per branch.  
3. Re-rank branches by priority and leafs by viability, ensuring alignment with:  
   - Mission: {mission}  
   - Opportunity/Problem: {opportunity_or_problem}  
   - Constraints: {constraints}  
   - Prior Ideas Summary: {summary_from_prompt_1} (avoid repetition).  
Provide updated Impact scores (0–100) for new or revised leafs.
```
